/**
 * Ad: Star Wars
 * Aciklama: Kotu karakterlerden kacarak çikisa ulasma oyunu
 * Tarih: 19 Mart 2019
 * Yapimci: Fatma Degirmenci & Berfin Kosemen
 * Numaralar: 170201008 & 170201058
 */


#include "Karakter.h"
#include "DarthVader.h"
#include "KyloRen.h"
#include "Lokasyon.h"
#include "LukeSkywalker.h"
#include "MasterYoda.h"
#include "StormTrooper.h"

#include <iostream>
#include <string>
#include <fstream> //Dosyalama islemleri icin gerekli olan kutuphane.
#include <sstream> //sstringstream icin
#include <iomanip> // formatli yazmak icin
#include<vector> //vektor kullanimi icin
#include <cmath> //shortestPath

#include "allegro5/allegro.h"
#include "allegro5/allegro_image.h"
#include "allegro5/allegro_primitives.h"
#include <allegro5/allegro_font.h>
#include <allegro5/allegro_ttf.h>

vector<int> finish, roots, rootsD;
vector <vector<int> >ways, waysD;

int olcum;
int returnDegeri;
using namespace std;

int numberOfBadCharacters;
string *badCharactersName;
string *gates;

Karakter *character;
DarthVader* Dv = nullptr;
KyloRen* Kr = nullptr;
Stormtrooper* St = nullptr;

string nameOfUsersCharacter;
vector<Karakter*> badCharacters;

//For restart
vector <int> firstLocationBadCharactersX, firstLocationBadCharactersY;
int firstLocationUserX, firstLocationUserY;

const float FPS = 8.5;
const int SCREEN_W = 750, SCREEN_H = 645;

const float addMotion = 35.0, startX = (SCREEN_W-(14*35)) / 2.0, startY = (SCREEN_H - (11*35)) / 2.0; //x icin 130, y icin 130

ALLEGRO_BITMAP * ZERO = NULL, *ONE = NULL, *A = NULL, *B = NULL, *C = NULL, *D = NULL, *E = NULL, *START = NULL;
ALLEGRO_BITMAP * AWARD = NULL, *LEFT = NULL, *RIGHT = NULL, *UP = NULL, *DOWN = NULL, *FULL = NULL, *HALFLEFT = NULL, *HALFRIGHT = NULL;
ALLEGRO_BITMAP *DARTHVADER = NULL, *STORMTROOPER = NULL, *KYLOREN = NULL, *MASTERYODA = NULL, *LUKESKYWALKER = NULL;
ALLEGRO_BITMAP * RED = NULL;

ALLEGRO_DISPLAY *display = NULL;
ALLEGRO_EVENT_QUEUE *event_queue = NULL;
ALLEGRO_TIMER *timer = NULL;

const int endpointX = startX+13*35, endpointY = startY+9*35;
bool gameStatus = true;

int map[11][14];

enum MYKEYS	{
	KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT
};

void activeAllegro();
void destroyAllegro();
void createDisplay();
void draw_map();
void drawRed();
void drawCharacter();
void createCharacter(string);
//void chooseCharacterType();
void readHaritaTxt();
void createBadCharacters();
void compareCoordinatesOfCharacters();
bool checkCharactersHealth();
bool checkGameStatus();
void drawBadCharacters();
void drawHealth();
void restartGame();
void assignStartingPoint();
void startOfCoordinatesBadCharacters();

int main(int argc, char **argv) {
	activeAllegro();
	//chooseCharacterType();
	readHaritaTxt();
	createBadCharacters();
	startOfCoordinatesBadCharacters();
	assignStartingPoint();
	createDisplay();
	draw_map();
	drawCharacter();

    return 0;
}

void activeAllegro() {
	al_init();
	al_init_image_addon();
	al_init_font_addon();
	al_init_ttf_addon();
	al_init_image_addon();
	al_install_keyboard();
}

void createDisplay() {
	display = al_create_display(SCREEN_W, SCREEN_H);
}

void destroyAllegro() {
	al_destroy_bitmap(character->character);
	al_destroy_timer(timer);
	al_destroy_display(display);
	al_destroy_event_queue(event_queue);
}

/*void chooseCharacterType() {
	int choice;
	x : cout << "\t2 Karakterden birini secin: \n" <<endl;
	cout << "\t\tMaster Yoda icin 1'e \n"
			"\t\tLuke Skywalker icin 2'ye\n\n"
			"\tbasin : ";
	cin >> choice;

	if(choice == 1) {
		nameOfUsersCharacter = "MasterYoda";
		createCharacter("MasterYoda");
	}
	else if(choice == 2) {
		nameOfUsersCharacter = "LukeSkywalker";
		createCharacter("LukeSkywalker");
	}
	else {
		cout << "\n\tHatali giris! Lutfen tekrar deneyiniz.\n" <<endl;
		goto x;
	}
}*/

void readHaritaTxt() {
	ifstream file;
	string word;
	int wordCounter = 0;

	file.open("Harita.txt");
	while(file >> word) {
		wordCounter++;
	}
	file.close();

	string allWords[wordCounter];

	file.open("Harita.txt");
	int i = 0;
	while(file >> word) {
		allWords[i] = word;
		i++;
	}

	numberOfBadCharacters = wordCounter - 11*14-1;

	int k=0;
	for(int i=0; i<11; i++) {
		for(int j=0; j<14; j++) {
			istringstream iss(allWords[numberOfBadCharacters+1+k]);
			iss >> map[i][j];
			k++;
		}
	}

	badCharactersName = new string[numberOfBadCharacters];
	gates = new string[numberOfBadCharacters];
    int sayac = 0;

	for(int i=0; i<=numberOfBadCharacters; i++) {
		char *arr = new char [allWords[i].length()+1];
		strcpy(arr, allWords[i].c_str());

		for(int j=0; j<strlen(arr); j++) {
			if(arr[j] == ':') {
			    if(arr[j+1] == 'M' && sayac == 0) {
                    nameOfUsersCharacter = "MasterYoda";
                    createCharacter("MasterYoda");
                    sayac++;
                    j += 10;
			    }
			    if(arr[j+1] == 'L' && sayac == 0) {
                    nameOfUsersCharacter = "LukeSkywalker";
                    createCharacter("LukeSkywalker");
                    sayac++;
                    j += 13;
			    }
			    else {
                    for(int k = j+1; k<strlen(arr); k++) {
                        if(arr[k] == ',') {
                            badCharactersName[i-1] = string(&arr[j+1], &arr[k]);
                        }
                        if(arr[k] == ',' && arr[k+5] == ':') {
                            gates[i-1] = string(&arr[k+6]);
                        }
                    }
                }
            }
        }
    }
}

void createCharacter(string characterType) {
	if(characterType.compare("MasterYoda") == 0) {

		character = new MasterYoda;
		character->character = al_load_bitmap("images\\images_MasterYoda.png");
	}
	else if(characterType.compare("LukeSkywalker") == 0) {
		character = new LukeSkywalker;
		character->character = al_load_bitmap("images\\images_LukeSkywalker.png");
	}

	al_set_target_bitmap(character->character);
	character->setXCoordinate(startX + 6*35);
	character->setYCoordinate(startY + 5*35);
}

void compareCoordinatesOfCharacters() {
	int flag = 0;

	for(int i=0; i<numberOfBadCharacters; i++) {
		if(badCharacters[i]->getXCoordinate() == character->getXCoordinate() &&
			badCharacters[i]->getYCoordinate() == character->getYCoordinate()) {
				flag++;
		}
	}

	if(flag != 0) {
		if(nameOfUsersCharacter == "MasterYoda") {
			character->setHealth(character->getHealth()-1);
			restartGame();
		}
		if(nameOfUsersCharacter == "LukeSkywalker")
			character->setHealth(character->getHealth()-2);
			restartGame();
	}

	draw_map();
    int olcum = 0;
	Karakter *p;

        for(int i=0; i<numberOfBadCharacters; i++) {
            p=badCharacters[i];
            if (Kr = dynamic_cast<KyloRen*>(p))
            {
                Kr->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
            }
            else if (Dv = dynamic_cast<DarthVader*>(p))
            {
                returnDegeri = Dv->shortestPath(&badCharacters, character, olcum, &finish, &waysD, &rootsD, i);
            }
            else if (St = dynamic_cast<Stormtrooper*>(p))
            {
                St->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
            }
        }

    drawRed();

	drawHealth();
}

bool checkCharactersHealth() {
	if(character->getHealth() == 0) {
		gameStatus = false;
		return false;
	}
	return true;
}

bool checkGameStatus() {
	if(character->getXCoordinate() == endpointX &&
		character->getYCoordinate() == endpointY) {
        gameStatus = false;
        return false;
	}
	return true;
}

void createBadCharacters() {
	for(int i=0; i<numberOfBadCharacters; i++) {
		if(gates[i].compare("A") == 0) {
			if(badCharactersName[i].compare("DarthVader") == 0) {
				badCharacters.push_back(new DarthVader());
			}
			if(badCharactersName[i].compare("KyloRen") == 0) {
				badCharacters.push_back(new KyloRen());
			}
			if(badCharactersName[i].compare("Stormtrooper") == 0) {
				badCharacters.push_back(new Stormtrooper());
			}

			badCharacters[i]->setXCoordinate(startX+0*35);
			badCharacters[i]->setYCoordinate(startX+5*35);
		}
		if(gates[i].compare("B") == 0) {
			if(badCharactersName[i].compare("DarthVader") == 0) {
				badCharacters.push_back(new DarthVader());
			}
			if(badCharactersName[i].compare("KyloRen") == 0) {
				badCharacters.push_back(new KyloRen());
			}
			if(badCharactersName[i].compare("Stormtrooper") == 0) {
				badCharacters.push_back(new Stormtrooper());
			}

			badCharacters[i]->setXCoordinate(startX+4*35);
			badCharacters[i]->setYCoordinate(startY+0*35);
		}
		if(gates[i].compare("C") == 0) {
			if(badCharactersName[i].compare("DarthVader") == 0) {
				badCharacters.push_back(new DarthVader());
			}
			if(badCharactersName[i].compare("KyloRen") == 0) {
				badCharacters.push_back(new KyloRen());
			}
			if(badCharactersName[i].compare("Stormtrooper") == 0) {
				badCharacters.push_back(new Stormtrooper());
			}

			badCharacters[i]->setXCoordinate(startX+12*35);
			badCharacters[i]->setYCoordinate(startY+0*35);
		}
		if(gates[i].compare("D") == 0) {
			if(badCharactersName[i].compare("DarthVader") == 0) {
				badCharacters.push_back(new DarthVader());
			}
			if(badCharactersName[i].compare("KyloRen") == 0) {
				badCharacters.push_back(new KyloRen());
			}
			if(badCharactersName[i].compare("Stormtrooper") == 0) {
				badCharacters.push_back(new Stormtrooper());
			}

			badCharacters[i]->setXCoordinate(startX+13*35);
			badCharacters[i]->setYCoordinate(startY+5*35);
		}
		if(gates[i].compare("E") == 0) {
			if(badCharactersName[i].compare("DarthVader") == 0) {
				badCharacters.push_back(new DarthVader());
			}
			if(badCharactersName[i].compare("KyloRen") == 0) {
				badCharacters.push_back(new KyloRen());
			}
			if(badCharactersName[i].compare("Stormtrooper") == 0) {
				badCharacters.push_back(new Stormtrooper());
			}

			badCharacters[i]->setXCoordinate(startX+4*35);
			badCharacters[i]->setYCoordinate(startY+10*35);
		}
	}
}

void draw_map() {
	bool redraw = true;

	DARTHVADER = al_load_bitmap("images\\images_DarthVader.png");
	STORMTROOPER = al_load_bitmap("images\\images_Stormtrooper.png");
	KYLOREN = al_load_bitmap("images\\images_KyloRen.png");
	MASTERYODA = al_load_bitmap("images\\images_MasterYoda.png");
	LUKESKYWALKER = al_load_bitmap("images\\images_LukeSkywalker.png");

	ZERO = al_load_bitmap("images\\images_0.png");
	ONE = al_load_bitmap("images\\images_1.png");
	A = al_load_bitmap("images\\images_A.png");
	B = al_load_bitmap("images\\images_B.png");
	C = al_load_bitmap("images\\images_C.png");
	D = al_load_bitmap("images\\images_D.png");
	E = al_load_bitmap("images\\images_E.png");
	START = al_load_bitmap("images\\images_BASLANGIC.png");

	RED = al_load_bitmap("images\\images_RED.png");

	AWARD = al_load_bitmap("images\\images_award.png");
	LEFT = al_load_bitmap("images\\images_left.png");
	RIGHT = al_load_bitmap("images\\images_right.png");
	UP = al_load_bitmap("images\\images_up.png");
	DOWN = al_load_bitmap("images\\images_down.png");
	FULL = al_load_bitmap("images\\images_full.png");
	HALFLEFT = al_load_bitmap("images\\images_halfleft.png");
	HALFRIGHT = al_load_bitmap("images\\images_halfright.png");

    al_clear_to_color(al_map_rgb(110,110,110));
	drawHealth();
	al_draw_bitmap(AWARD, startX+14*35, startY+9*35-10, 0);

	int del = 5;
	for(int i=0; i<11; i++) {
		for(int j=0; j<14; j++) {
			if(i==5 && j==6) {
				al_draw_bitmap(START, startX+j*35, startY+i*35, 0);
			}
			else if(i==5 && j==0) {
				al_draw_bitmap(A, startX+j*35, startY+i*35, 0);
				al_draw_bitmap(RIGHT, startX+(j-1)*35-del, startY+i*35, 0);
			}
			else if(i==0 && j==4) {
				al_draw_bitmap(B, startX+j*35, startY+i*35, 0);
				al_draw_bitmap(DOWN, startX+j*35-del, startY * (i-1)*35, 0);
			}
			else if(i==0 && j==12) {
				al_draw_bitmap(C, startX+j*35, startY+i*35, 0);
				al_draw_bitmap(DOWN, startX+j*35-del, startY+(i-1)*35, 0);
			}
			else if(i==5 && j==13) {
				al_draw_bitmap(D, startX+j*35, startY+i*35, 0);
				al_draw_bitmap(LEFT, startX+(j+1)*35-del, startY+i*35, 0);
			}
			else if(i==10 && j==4) {
				al_draw_bitmap(E, startX+j*35, startY+i*35, 0);
				al_draw_bitmap(UP, startX+j*35-del, startY+(i+1)*35, 0);
			}
			else if(map[i][j] == 0) {
				al_draw_bitmap(ZERO, startX+j*35, startY+i*35, 0);
			}
			else if(map[i][j]== 1) {
				al_draw_bitmap(ONE, startX+j*35, startY+i*35, 0);
			}
		}
	}

	ALLEGRO_FONT *font = al_load_ttf_font("fonts\\fonts_pirulen.ttf", 24, 0);
	al_draw_text(font, al_map_rgb(0,0,0), startX+10*35+15, startY-3*35+5, ALLEGRO_ALIGN_CENTER, "Canlar: ");

	ALLEGRO_FONT *font3 = al_load_ttf_font("fonts\\fonts_AdventPro-Regular.ttf", 30, 0);
}

void drawRed() {
    ALLEGRO_FONT *font3 = al_load_ttf_font("fonts\\fonts_AdventPro-Regular.ttf", 20, 0);

    int intText, artis = 0;
    string strText,type, coordx, coordy, coordx2, coordy2, all;

    if(olcum==0) {
        for(int i=0;i<finish.size();i++) {
            Karakter *p;
            p=badCharacters[i];

            if (Dv = dynamic_cast<DarthVader*>(p)) {
                for(int j=1; j<waysD[returnDegeri].size(); j++) {
                    al_draw_bitmap(RED, rootsD[waysD[returnDegeri][j]*2]*35+130, rootsD[waysD[returnDegeri][j]*2+1]*35+130, 0);
                }
            }
            else {
                for(int j=1; j<ways[finish.at(i)].size(); j++)
                    al_draw_bitmap(RED, roots[ways[finish.at(i)][j]*2]*35+130, roots[ways[finish.at(i)][j]*2+1]*35+130, 0);
            }


            type = badCharactersName[i];
            coordx = to_string((badCharacters[i]->getXCoordinate()-130)/35);
            coordy = to_string((badCharacters[i]->getYCoordinate()-130)/35);
            coordx2 = to_string((character->getXCoordinate()-130)/35);
            coordy2 = to_string((character->getYCoordinate()-130)/35);
            all = type + " (" + coordx + ", " + coordy + ")'den (" + coordx2 + ", " + coordy2 + ")'ya";

            const char* chrAll = all.c_str();
            al_draw_text(font3, al_map_rgb(0,0,0), 120, 565+artis, ALLEGRO_ALIGN_LEFT, chrAll);

            if (Dv = dynamic_cast<DarthVader*>(p))
                intText = waysD[returnDegeri].size()-1;
            else if(Kr = dynamic_cast<KyloRen*>(p))
                intText = (ways[finish.at(i)].size())/2;
            else
                intText = ways[finish.at(i)].size()-1;

            strText = to_string(intText);
            char const *chrText = strText.c_str();
            al_draw_text(font3, al_map_rgb(0,0,0), 390, 565+artis, ALLEGRO_ALIGN_LEFT, chrText);
            al_draw_text(font3, al_map_rgb(0,0,0), 405, 565+artis, ALLEGRO_ALIGN_LEFT, "adimda ulasir");
            artis += 20;
        }
    }
    else {
       for(int i=0;i<finish.size();i++) {
            Karakter *p;
            p=badCharacters[i];
            if(i==0) {
                if (Dv = dynamic_cast<DarthVader*>(p)) {
                    for(int j=1; j<waysD[returnDegeri].size(); j++) {
                        al_draw_bitmap(RED, rootsD[waysD[returnDegeri][j]*2]*35+130, rootsD[waysD[returnDegeri][j]*2+1]*35+130, 0);
                    }
                }
                 else if (Kr = dynamic_cast<KyloRen*>(p)){
                    for(int j=1; j<ways[finish.at(i)].size(); j++)
                        al_draw_bitmap(RED, roots[ways[finish.at(i)][j]*2]*35+130, roots[ways[finish.at(i)][j]*2+1]*35+130, 0);
                }
                else {
                    for(int j=1; j<ways[finish.at(i)].size(); j++)
                        al_draw_bitmap(RED, roots[ways[finish.at(i)][j]*2]*35+130, roots[ways[finish.at(i)][j]*2+1]*35+130, 0);
                }
            }
            else {
                if (Dv = dynamic_cast<DarthVader*>(p)) {
                    for(int j=1; j<waysD[returnDegeri].size(); j++) {
                        al_draw_bitmap(RED, rootsD[waysD[returnDegeri][j]*2]*35+130, rootsD[waysD[returnDegeri][j]*2+1]*35+130, 0);
                    }
                }
                 else if (Kr = dynamic_cast<KyloRen*>(p)){
                    for(int j=1; j<ways[finish.at(i)].size(); j++)
                        al_draw_bitmap(RED, roots[ways[finish.at(i)][j]*2]*35+130, roots[ways[finish.at(i)][j]*2+1]*35+130, 0);
                }
                else {
                    for(int j=1; j<ways[finish.at(i)].size(); j++)
                        al_draw_bitmap(RED, roots[ways[finish.at(i)][j]*2]*35+130, roots[ways[finish.at(i)][j]*2+1]*35+130, 0);
                }
            }

            type = badCharactersName[i];
            coordx = to_string((badCharacters[i]->getXCoordinate()-130)/35);
            coordy = to_string((badCharacters[i]->getYCoordinate()-130)/35);
            coordx2 = to_string((character->getXCoordinate()-130)/35);
            coordy2 = to_string((character->getYCoordinate()-130)/35);
            all = type + " (" + coordx + ", " + coordy + ")'den (" + coordx2 + ", " + coordy2 + ")'ya";

            const char* chrAll = all.c_str();
            al_draw_text(font3, al_map_rgb(0,0,0), 120, 565+artis, ALLEGRO_ALIGN_LEFT, chrAll);

            if(i==0) {
                if (Dv = dynamic_cast<DarthVader*>(p))
                    intText = waysD[returnDegeri].size()-1;
                else if(Kr = dynamic_cast<KyloRen*>(p))
                    intText = (ways[finish.at(i)].size())/2;
                else
                    intText = ways[finish.at(i)].size()-1;
            }
            else {
                if (Dv = dynamic_cast<DarthVader*>(p))
                    intText = waysD[returnDegeri].size()-1;
                else if(Kr = dynamic_cast<KyloRen*>(p))
                    intText = (ways[finish.at(i)].size())/2;
                else
                    intText = ways[finish.at(i)].size()-1;
            }


            strText = to_string(intText);
            char const *chrText = strText.c_str();
            al_draw_text(font3, al_map_rgb(0,0,0), 390, 565+artis, ALLEGRO_ALIGN_LEFT, chrText);
            al_draw_text(font3, al_map_rgb(0,0,0), 405, 565+artis, ALLEGRO_ALIGN_LEFT, "adimda ulasir");
            artis += 20;
        }
    }
}

void drawCharacter() {
	int src = 43;
	int NUMBEROFNODES;

	NUMBEROFNODES = 43 + 1 + numberOfBadCharacters; //43 dugum 1 iyi karakter 1 kotu karakter

	bool key[4] = {false, false, false, false};
	bool redraw = true;
	bool doexit = false;

	timer = al_create_timer(1.0/FPS);

	al_set_target_bitmap(al_get_backbuffer(display));
	event_queue = al_create_event_queue();

	al_register_event_source(event_queue, al_get_display_event_source(display));
	al_register_event_source(event_queue, al_get_timer_event_source(timer));
	al_register_event_source(event_queue, al_get_keyboard_event_source());

	al_start_timer(timer);

    draw_map();
	olcum = 0;
	Karakter *p;

        for(int i=0; i<numberOfBadCharacters; i++) {
            p=badCharacters[i];
            if (Kr = dynamic_cast<KyloRen*>(p))
            {
                Kr->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
            }
            else if (Dv = dynamic_cast<DarthVader*>(p))
            {
                returnDegeri = Dv->shortestPath(&badCharacters, character, olcum, &finish, &waysD, &rootsD, i);
            }
            else if (St = dynamic_cast<Stormtrooper*>(p))
            {
                St->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
            }
        }
        drawRed();

	while(!doexit) {
		ALLEGRO_EVENT ev;
		al_wait_for_event(event_queue, &ev);

		if(!checkGameStatus()) {
			ALLEGRO_BITMAP * youWinBackground = NULL;
			youWinBackground = al_create_bitmap(750, 645);
			al_set_target_bitmap(youWinBackground);

			al_clear_to_color(al_map_rgb(0, 0, 0));
			al_set_target_bitmap(al_get_backbuffer(display));

			al_draw_bitmap(youWinBackground, 0, 0, 0);

			ALLEGRO_FONT *youWinText = al_load_ttf_font("fonts_pirulen.ttf", 48, 0);

			al_rest(0.1);

			al_draw_text(youWinText, al_map_rgb(255, 255, 255), 750/2, 645/2, ALLEGRO_ALIGN_CENTER, "YOU WIN");

			al_flip_display();

			if(ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
					break;
				}

			al_rest(5.0);
			break;
		}
		if(!checkCharactersHealth()) {
			ALLEGRO_BITMAP * gameOverBackground = NULL;
			gameOverBackground = al_create_bitmap(750, 645);
			al_set_target_bitmap(gameOverBackground);

			al_clear_to_color(al_map_rgb(0, 0, 0));
			al_set_target_bitmap(al_get_backbuffer(display));

			al_draw_bitmap(gameOverBackground, 0, 0, 0);
			ALLEGRO_FONT *gameOverText = al_load_ttf_font("fonts_pirulen.ttf", 48, 0);
			al_rest(0.1);

			al_draw_text(gameOverText, al_map_rgb(255, 255, 255), 750/2, 645/2-30, ALLEGRO_ALIGN_CENTER, "YOU LOSE");
			al_draw_text(gameOverText, al_map_rgb(255, 255, 255), 750/2, 645/2+30, ALLEGRO_ALIGN_CENTER, "GAME OVER");

			al_flip_display();

			if(ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
                break;
            }

			al_rest(5.0);
			break;
		}

		if(ev.type == ALLEGRO_EVENT_TIMER) {
			if(key[KEY_UP] && character->getYCoordinate() > startY && (map[((int)character->getYCoordinate()-(int)addMotion-130)/35][((int)character->getXCoordinate()-130)/35] != 0)) {
                character->setYCoordinate(character->getYCoordinate()-addMotion);
                //compareCoordinatesOfCharacters();
                olcum++;
                for(int i=0; i<numberOfBadCharacters; i++) {
                    p=badCharacters[i];
                    if (Kr = dynamic_cast<KyloRen*>(p)) {
                        Kr->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                    else if (Dv = dynamic_cast<DarthVader*>(p)) {
                        returnDegeri = Dv->shortestPath(&badCharacters, character, olcum, &finish, &waysD, &rootsD, i);
                    }
                    else if (St = dynamic_cast<Stormtrooper*>(p)) {
                        St->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                }
                compareCoordinatesOfCharacters();
				drawBadCharacters();
			}
			if(key[KEY_DOWN] && character->getYCoordinate() < startY+10*35 && (map[((int)character->getYCoordinate()+(int)addMotion-130)/35][((int)character->getXCoordinate()-130)/35] != 0)) {
                character->setYCoordinate(character->getYCoordinate()+addMotion);
            //    compareCoordinatesOfCharacters();
                olcum++;
                for(int i=0; i<numberOfBadCharacters; i++) {
                    p=badCharacters[i];
                    if (Kr = dynamic_cast<KyloRen*>(p))
                    {
                        Kr->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                    else if (Dv = dynamic_cast<DarthVader*>(p))
                    {
                        returnDegeri = Dv->shortestPath(&badCharacters, character, olcum, &finish, &waysD, &rootsD, i);
                    }
                    else if (St = dynamic_cast<Stormtrooper*>(p))
                    {
                        St->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                }
                compareCoordinatesOfCharacters();
				drawBadCharacters();
			}
			if(key[KEY_LEFT] &&  character->getXCoordinate() > startX && (map[((int)character->getYCoordinate()-130)/35][((int)(character->getXCoordinate()-addMotion)-130)/35] != 0)) {
				character->setXCoordinate(character->getXCoordinate()-addMotion);
			//	compareCoordinatesOfCharacters();
				olcum++;
				for(int i=0; i<numberOfBadCharacters; i++) {
                    p=badCharacters[i];
                    if (Kr = dynamic_cast<KyloRen*>(p))
                    {
                        Kr->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                    else if (Dv = dynamic_cast<DarthVader*>(p))
                    {
                        returnDegeri = Dv->shortestPath(&badCharacters, character, olcum, &finish, &waysD, &rootsD, i);
                    }
                    else if (St = dynamic_cast<Stormtrooper*>(p))
                    {
                        St->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                }

                compareCoordinatesOfCharacters();
				drawBadCharacters();
			}
			if(key[KEY_RIGHT] && character->getXCoordinate() < startX + 13*35 && (map[((int)(character->getYCoordinate())-130)/35][((int)(character->getXCoordinate())+(int)addMotion-130)/35] != 0)) {
                character->setXCoordinate(character->getXCoordinate()+addMotion);
        //        compareCoordinatesOfCharacters();
                olcum++;
				for(int i=0; i<numberOfBadCharacters; i++) {
                    p=badCharacters[i];
                    if (Kr = dynamic_cast<KyloRen*>(p))
                    {
                        Kr->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                    else if (Dv = dynamic_cast<DarthVader*>(p))
                    {
                        returnDegeri = Dv->shortestPath(&badCharacters, character, olcum, &finish, &waysD, &rootsD, i);
                    }
                    else if (St = dynamic_cast<Stormtrooper*>(p))
                    {
                        St->shortestPath(&badCharacters, character, olcum, &finish, &ways, &roots, i);
                    }
                }

                compareCoordinatesOfCharacters();
				drawBadCharacters();
			}
			redraw = true;
		}
		else if(ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
			break;
		}
		else if(ev.type == ALLEGRO_EVENT_KEY_DOWN) { // herhangi bi tusa basildiginda hareketi aktiflestiriyo
			switch(ev.keyboard.keycode) {
				case ALLEGRO_KEY_UP:
					key[KEY_UP] = true;
					break;

				case ALLEGRO_KEY_DOWN:
					key[KEY_DOWN] = true;
					break;

				case ALLEGRO_KEY_LEFT:
					key[KEY_LEFT] = true;
					break;

				case ALLEGRO_KEY_RIGHT:
					key[KEY_RIGHT] = true;
					break;
			}
		}
		else if(ev.type == ALLEGRO_EVENT_KEY_UP) {
			switch(ev.keyboard.keycode) {
				case ALLEGRO_KEY_UP:
					key[KEY_UP] = false;
					draw_map();
					drawRed();

					break;

				case ALLEGRO_KEY_DOWN:
					key[KEY_DOWN] = false;
					draw_map();
					drawRed();
					break;

				case ALLEGRO_KEY_LEFT:
					key[KEY_LEFT] = false;
					draw_map();
					drawRed();
					break;

				case ALLEGRO_KEY_RIGHT:
					key[KEY_RIGHT] = false;
					draw_map();
					drawRed();
					break;

				case ALLEGRO_KEY_ESCAPE:
					doexit = true;
					draw_map();
					break;
			}
		}

		if(redraw && al_is_event_queue_empty(event_queue)) {
			redraw = false;

			al_draw_bitmap(character->character,character->getXCoordinate(), character->getYCoordinate(), 0);
			drawBadCharacters();

			al_flip_display();
		}
	}
}

void drawBadCharacters() {
	for(int i=0; i<numberOfBadCharacters; i++) {
		if(badCharactersName[i].compare("DarthVader") == 0) {
			al_draw_bitmap(DARTHVADER, badCharacters[i]->getXCoordinate(), badCharacters[i]->getYCoordinate(), 0);
		}
		if(badCharactersName[i].compare("Stormtrooper") == 0) {
			al_draw_bitmap(STORMTROOPER, badCharacters[i]->getXCoordinate(), badCharacters[i]->getYCoordinate(), 0);
		}
		if(badCharactersName[i].compare("KyloRen") == 0) {
			al_draw_bitmap(KYLOREN, badCharacters[i]->getXCoordinate(), badCharacters[i]->getYCoordinate(), 0);
		}
	}
	al_flip_display();
}

void startOfCoordinatesBadCharacters() {
	for(int i=0; i<numberOfBadCharacters; i++) {
		if(gates[i].compare("A") == 0) {
			badCharacters[i]->setXCoordinate(startX+0*35);
			badCharacters[i]->setYCoordinate(startY+5*35);
		}
		if(gates[i].compare("B") == 0) {
			badCharacters[i]->setXCoordinate(startX+4*35);
			badCharacters[i]->setYCoordinate(startY+0*35);
		}
		if(gates[i].compare("C") == 0) {
			badCharacters[i]->setXCoordinate(startX+12*35);
			badCharacters[i]->setYCoordinate(startY+0*35);
		}
		if(gates[i].compare("D") == 0) {

			badCharacters[i]->setXCoordinate(startX+13*35);
			badCharacters[i]->setYCoordinate(startY+5*35);
		}
		if(gates[i].compare("E") == 0) {

			badCharacters[i]->setXCoordinate(startX+4*35);
			badCharacters[i]->setYCoordinate(startY+10*35);
		}
	}
}

void drawHealth() {
	if(character->getHealth() == 6) {
		al_draw_bitmap(FULL, startX+13*35, startY-3*35, 0);
		al_draw_bitmap(FULL, startX+14*35, startY-3*35, 0);
		al_draw_bitmap(FULL, startX+15*35, startY-3*35, 0);
	}
	else if(character->getHealth() == 5) {
		al_draw_bitmap(FULL, startX+13*35, startY-3*35, 0);
		al_draw_bitmap(FULL, startX+14*35, startY-3*35, 0);
		al_draw_bitmap(HALFLEFT, startX+15*35, startY-3*35, 0);
	}
	else if(character->getHealth() == 4) {
		al_draw_bitmap(FULL, startX+13*35, startY-3*35, 0);
		al_draw_bitmap(FULL, startX+14*35, startY-3*35, 0);
	}
	else if(character->getHealth() == 3) {
		al_draw_bitmap(FULL, startX+13*35, startY-3*35, 0);
		al_draw_bitmap(HALFLEFT, startX+14*35, startY-3*35, 0);
	}
	else if(character->getHealth() == 2) {
		al_draw_bitmap(FULL, startX+13*35, startY-3*35, 0);
	}
	else if(character->getHealth() == 1) {
		al_draw_bitmap(HALFLEFT, startX+13*35, startY-3*35, 0);
	}
	else if(character->getHealth() == 5) {
		/**/
	}
	al_flip_display();
}

void assignStartingPoint() {
	firstLocationUserX = character->getXCoordinate();
	firstLocationUserY = character->getYCoordinate();

	for(int i=0; i<numberOfBadCharacters; i++) {
		firstLocationBadCharactersX.push_back(badCharacters[i]->getXCoordinate());
		firstLocationBadCharactersY.push_back(badCharacters[i]->getYCoordinate());
	}
}

void restartGame() {
	character->setXCoordinate(firstLocationUserX);
	character->setYCoordinate(firstLocationUserY);

	for(int i=0; i<numberOfBadCharacters; i++) {
		badCharacters[i]->setXCoordinate(firstLocationBadCharactersX.at(i));
		badCharacters[i]->setYCoordinate(firstLocationBadCharactersY.at(i));
	}


}











#ifndef DARTHVADER_H
#define DARTHVADER_H
#include "Karakter.h"
#include "KyloRen.h"
#include "DarthVader.h"
#include "Stormtrooper.h"

class DarthVader : public Karakter
{
	public:
		DarthVader();
		virtual ~DarthVader();
		int shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index);

	protected:

	private:
};

#endif // DARTHVADER_H


#ifndef KARAKTER_H
#define KARAKTER_H
#include <string>
#include "Lokasyon.h"
#include <vector>
#include "allegro5/allegro.h"

using namespace std;
class Karakter : public Lokasyon
{
	public:
		Karakter();
		virtual ~Karakter();

		vector <vector<int> > nodes;
		ALLEGRO_BITMAP *character = NULL;

		string getCharacterName();
		string getCharacterType();

		void setCharacterName(string);
		void setCharacterType(string);

        virtual int shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index);
		virtual int getHealth(){}
		virtual void setHealth(int){}

	protected:

	private:
		int health;
		string characterName; //karakter adi
		string characterType; //karakter turu(iyi/kotu)
		Lokasyon coordinates; //karakterin ilerledigi koordinatlari tutacak

};


#endif // KARAKTER_H

#ifndef KYLOREN_H
#define KYLOREN_H
#include "Karakter.h"

#include "KyloRen.h"

using namespace std;

class KyloRen: public Karakter //cok hizli. tek hamlede 2 basamak ilerliyor
{
	public:
		KyloRen();
		virtual ~KyloRen();
        virtual int shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index); //en kisa yol algoritmasi
};

#endif // KYLOREN_H

#ifndef LOKASYON_H
#define LOKASYON_H
#include <string>

class Lokasyon
{
	public:
		Lokasyon();
		virtual ~Lokasyon();

		int getXCoordinate();
		int getYCoordinate();

		void setXCoordinate(int);
		void setYCoordinate(int);

	protected:

	private:
		int x;
		int y;
};


#endif // LOKASYON_H

#ifndef LUKESKYWALKER_H
#define LUKESKYWALKER_H
#include <string>
#include "Karakter.h"

class LukeSkywalker: public Karakter
{
	public:
		LukeSkywalker();
		virtual ~LukeSkywalker();

		int getHealth();
		void setHealth(int);

	protected:

	private:
		int health;
};






#endif // LUKESKYWALKER_H

#ifndef MASTERYODA_H
#define MASTERYODA_H
#include <string>
#include "Karakter.h"

class MasterYoda: public Karakter //kotu karaktere yakalaninca cani yariya iniyor
{
	public:
		MasterYoda();
		virtual ~MasterYoda();

		int getHealth();
		void setHealth(int);

	protected:

	private:
		int health;

};

#endif // MASTERYODA_H

#ifndef STORMTROOPER_H
#define STORMTROOPER_H
#include "Karakter.h"

class Stormtrooper : public Karakter
{
	public:
		Stormtrooper();
		virtual ~Stormtrooper();
        virtual int shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index);

	protected:

	private:
};

#endif // STORMTROOPER_H



#include "DarthVader.h"
#include <cmath>

DarthVader::DarthVader() {
	setCharacterType("kotu");
}

DarthVader::~DarthVader() {
	//dtor
}
int DarthVader::shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index) { //en kisa yol algoritmasi

    int **matris;
    vector<int>roots;
    int V;
	int root[228] = { 4,0, 12,0, 1,1, 2,1, 3,1, 4,1, 5,1, 6,1, 7,1, 8,1, 9,1, 10,1, 11,1,
	12,1, 1,2, 2,2, 3,2, 4,2, 5,2, 6,2, 7,2, 8,2, 9,2, 10,2, 11,2, 12,2, 1,3, 2,3, 3,3, 4,3, 5,3,
	6,3, 7,3, 8,3, 9,3, 10,3, 11,3, 12,3, 1,4, 2,4, 3,4, 4,4, 5,4, 6,4, 7,4, 8,4, 9,4, 10,4, 11,4, 12,4, 0,5,
	1,5, 2,5, 3,5, 4,5, 5,5, 6,5, 7,5, 8,5, 9,5, 10,5, 11,5, 12,5, 13,5, 1,6, 2,6, 3,6, 4,6, 5,6, 6,6, 7,6, 8,6, 9,6,
	 10,6, 11,6, 12,6, 1,7, 2,7, 3,7, 4,7, 5,7, 6,7, 7,7, 8,7, 9,7, 10,7, 11,7, 12,7, 1,8, 2,8, 3,8, 4,8, 5,8, 6,8, 7,8, 8,8, 9,8, 10,8, 11,8, 12,8, 1,9, 2,9, 3,9, 4,9, 5,9, 6,9, 7,9, 8,9, 9,9, 10,9, 11,9, 12,9, 13,9, 4,10};

	for(int p=0;p<228;p++){
		 roots.push_back(root[p]);
	}

	int start;
	vector<int>finish;

	int fini[(*badCharacters).size()];
    int sayici[(*badCharacters).size()];

    for(int i=0; i<(*badCharacters).size(); i++) {
        sayici[i] = -1;
        fini[i] = -1;
    }

	for(int i=0;i<(*badCharacters).size();i++){
        for(int p=0;p<228;p+=2){
    		if(((*badCharacters)[i]->getXCoordinate()-130)/35 == root[p] &&  ((*badCharacters)[i]->getYCoordinate()-130)/35 == root[p+1]){
    			finish.push_back(p/2);
    			sayici[i]++;
			}
		}
	}

    int cikar = 0;
    for(int i=0; i<(*badCharacters).size(); i++) {
        if(sayici[i] != -1) {
            fini[i] = finish.at(i-cikar);
        }
        if(sayici[i] == -1) {
            cikar ++;
        }
	}

    for(int p=0;p<228;p+=2){
        if((character->getXCoordinate()-130)/35 == root[p] && (character->getYCoordinate()-130)/35 == root[p+1]){
            start = p/2;
        }
    }

    V = roots.size()/2;

	int f3 = 15;
	int a[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int a1[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int a2[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int t=0,t1=0,mesafe,sayac2=0,kt;

	matris = new int*[V];
	for(int i=0; i<V; i++) {
		matris[i] = new int [V];
	}

	for(int i=0;i<V;i++){
		for(int j=0;j<V;j++){
			matris[i][j] = 0;
		}
	}

	for(int i=0;i<14;i++){
		for(int j=0;j<roots.size();j+=2){
			if(i == roots.at(j)){
				for(int k=0;k<roots.size();k+=2){
					if(i == roots.at(k) && k != j){
						a[t] = roots.at(k+1);
						t++;
						t1=t;
					}
				}
				t=0;
				if(t1 > 1){
                    int min = fabs(roots.at(j+1) - a[0]);
                    int value = a[0];
                    kt=0;

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j+1) - a[k1]) < min){
                            min = fabs(roots.at(j+1) - a[k1]);
                            value = a[k1];
                            kt = k1;
                        }
                    }

                    int value2;
                    if(roots.at(j+1) > a[kt]){
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j+1) < a[k1] && a[k1] != 50){
                                a1[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j+1) - a1[0]);
                        value2 = a1[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j+1) - a1[k1]) < min){
                                min = fabs(roots.at(j+1) - a1[k1]);
                                value2 = a1[k1];
                            }
                        }
                    }
                    else{
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j+1) > a[k1] && a[k1] != 50){
                                a2[k1] = a[k1];
                                sayac2++;
                            }
                        }
                        min = fabs(roots.at(j+1) - a2[0]);
                        value2 = a2[0];
                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j+1) - a2[k1]) < min){
                                min = fabs(roots.at(j+1) - a2[k1]);
                                value2 = a2[k1];
                            }
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a1[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a2[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j+1)- value);

                    for(int i1=0;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1+1) == value){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }

                    if(sayac2 != 0){
                        mesafe = fabs(roots.at(j+1)- value2);

                        for(int i1=0;i1<roots.size();i1+=2){
                            if(roots.at(i1) == i && roots.at(i1+1) == value2){
                                matris[j/2][i1/2] = mesafe;
                                matris[i1/2][j/2] = mesafe;
                            }
                        }

                    }
                    sayac2 = 0;
				}

				if(t1 == 1){
                    int min = fabs(roots.at(j+1) - a[0]);
                    int value = a[0];
                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j+1) - a[k1]) < min){
                            min = fabs(roots.at(j+1) - a[k1]);
                            value = a[k1];
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j+1)- value);

                    for(int i1=0;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1+1) == value){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
				}
				t1=0;
			}
		}
	}

	t=0;
	t1=0;

	for(int i=0;i<11;i++){
		for(int j=1;j<roots.size();j+=2){
			if(i == roots.at(j)){
				for(int k=1;k<roots.size();k+=2){
					if(i == roots.at(k) && k != j){
						a[t] = roots.at(k-1);
						t++;
						t1=t;
					}
				}

				t=0;
				if(t1 > 1){
                    int min = fabs(roots.at(j-1) - a[0]);
                    int value1 = a[0];
                    kt = 0;

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j-1) - a[k1]) < min){
                            min = fabs(roots.at(j-1) - a[k1]);
                            value1 = a[k1];
                            kt =k1;
                        }
                    }

                    int value3;
                    if(roots.at(j-1) > a[kt]){
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j-1) < a[k1] && a[k1] != 50){
                                a1[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j-1) - a1[0]);
                        value3 = a1[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j-1) - a1[k1]) < min){
                                min = fabs(roots.at(j-1) - a1[k1]);
                                value3 = a1[k1];
                            }
                        }
                    }
                    else{
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j-1) > a[k1] && a[k1] != 50){
                                a2[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j-1) - a2[0]);
                        value3 = a2[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j-1) - a2[k1]) < min){
                                min = fabs(roots.at(j-1) - a2[k1]);
                                value3 = a2[k1];
                            }
                        }
                    }
                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a1[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a2[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j-1)- value1);

                    for(int i1=1;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1-1) == value1){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }

                    if(sayac2 != 0){
                        mesafe = fabs(roots.at(j-1)- value3);

                        for(int i1=1;i1<roots.size();i1+=2){
                            if(roots.at(i1) == i && roots.at(i1-1) == value3){
                                matris[j/2][i1/2] = mesafe;
                                matris[i1/2][j/2] = mesafe;
                            }
                        }
                    }
                    sayac2 = 0;
				}
				if( t1 == 1){
                    int min = fabs(roots.at(j-1) - a[0]);
                    int value1 = a[0];

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j-1) - a[k1]) < min){
                            min = fabs(roots.at(j-1) - a[k1]);
                            value1 = a[k1];
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j-1)- value1);

                    for(int i1=1;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1-1) == value1){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
				}
				t1=0;
			}
		}
	}

    int distance[V];
    bool Set[V];

    for (int i = 0; i < V; i++)
       distance[i] = INT_MAX, Set[i] = false;

    distance[start] = 0;

     int way[V][V];
     for(int i=0;i<V;i++){
     	for(int j=0;j<V;j++){
     		way[i][j] = -1;
		 }
	 }

     int v1[V];

     for(int i=0;i<V;i++)
     	v1[i]= -1;

     int i1,j=0;

     for (int count = 0; count < V-1; count++){
       int min = INT_MAX, min_index;

   		for (int v = 0; v < V; v++){
			if (Set[v] == false && distance[v] <= min){
				min = distance[v];
				min_index = v;
			}
   		}

       int u = min_index;

       Set[u] = true;

       for (int v = 0; v < V; v++)
         if (Set[v] == false && matris[u][v] != 0 && distance[u]+matris[u][v] < distance[v]) {
		 	distance[v] = distance[u] + matris[u][v];
		 	way[v][0] = u;
		 	way[v][1] = v;
		 	for(int k=0;k<V;k++){
		 		if(v1[k] == u){
		 			for(int i=0;i<V;i++){
		 				way[v][i] = way[u][i];
                        if(way[u][i] != -1)
                            i1 = i;
				 	}
		 			way[v][i1+1] = v;
				}
			}
		 	v1[j] =v;
		 	j++;
		 }
     }

    vector <vector <int> >ways;
    for(int i=0;i<V;i++){
        vector <int> row2;
        for(int j=0;j<V;j++){
            if(way[i][j] != -1)
                row2.push_back(way[i][j]);
        }
        ways.push_back(row2);
    }

    if(olcum == 0) {
        (*badCharacters)[index]->setXCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-1]*2]*35+130);
        (*badCharacters)[index]->setYCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-1]*2+1]*35+130);
    }
    else {
        (*badCharacters)[index]->setXCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-2]*2]*35+130);
        (*badCharacters)[index]->setYCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-2]*2+1]*35+130);
    }


    (*fin).clear();

    for(int i=0; i<(*badCharacters).size(); i++) {
        fin->push_back(fini[i]);
    }

    (*coord).clear();
    for(int i=0; i<ways.size(); i++) {
        vector <int> row1;

        for(int j=0; j<ways[i].size(); j++) {
            row1.push_back(ways[i][j]);
        }
        coord->push_back(row1);
    }

    (*ro).clear();
     for(int i=0; i<roots.size(); i++) {
        ro->push_back(roots[i]);
    }

    int returnEt = fini[index];

    roots.clear();
    finish.clear();
    ways.clear();

    return returnEt;

}


#include "Karakter.h"
#include <cmath>

using namespace std;

Karakter::Karakter() {
}

Karakter::~Karakter()
{
	//dtor
}

string Karakter::getCharacterName() {
	return characterName;
}

void Karakter::setCharacterName(string characterName) {
	this->characterName = characterName;
}

string Karakter::getCharacterType() {
	return characterType;
}

void Karakter::setCharacterType(string characterType) {
	this->characterType = characterType;
}

int Karakter::shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index) {
}



#include "KyloRen.h"
#include <cmath>

using namespace std;

KyloRen::KyloRen() {
	setCharacterType("kotu");
}

KyloRen::~KyloRen()
{
	//dtor
}

int KyloRen::shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index) { //en kisa yol algoritmasi

    int **matris;
    vector<int>roots;
    int V;
	int root[156] = {4,0, 12,0, 1,1, 2,1, 3,1, 4,1, 6,1, 7,1, 8,1, 9,1, 10,1, 11,1, 12,1, 1,2, 3,2, 4,2, 5,2, 6,2, 8,2, 12,2, 1,3, 3,3, 4,3, 6,3, 8,3, 9,3, 11,3, 12,3, 1,4, 3,4, 6,4, 8,4, 9,4, 11,4, 12,4, 0,5, 1,5, 3,5, 4,5, 5,5, 6,5, 8,5, 12,5, 13,5, 1,6, 4,6, 6,6, 8,6, 10,6, 11,6, 12,6, 1,7, 3,7, 4,7, 5,7, 6,7, 7,7, 8,7, 12,7, 1,8, 3,8, 8,8, 11,8, 12,8, 1,9, 2,9, 3,9, 4,9, 5,9, 6,9, 7,9, 8,9, 9,9, 10,9, 11,9, 12,9, 13,9, 4,10};

	for(int p=0;p<156;p++){
		 roots.push_back(root[p]);
	}

	int start;
	vector<int>finish;

    int fini[(*badCharacters).size()];
    int sayici[(*badCharacters).size()];

    for(int i=0; i<(*badCharacters).size(); i++) {
        sayici[i] = -1;
        fini[i] = -1;
    }

	for(int i=0;i<(*badCharacters).size();i++){
        for(int p=0;p<156;p+=2){
    		if(((*badCharacters)[i]->getXCoordinate()-130)/35 == root[p] &&  ((*badCharacters)[i]->getYCoordinate()-130)/35 == root[p+1]){
    			finish.push_back(p/2);
    			sayici[i]++;
			}
		}
	}

    int cikar = 0;
    for(int i=0; i<(*badCharacters).size(); i++) {
        if(sayici[i] != -1) {
            fini[i] = finish.at(i-cikar);
        }
        if(sayici[i] == -1) {
            cikar ++;
        }
	}

    for(int p=0;p<156;p+=2){
        if((character->getXCoordinate()-130)/35 == root[p] && (character->getYCoordinate()-130)/35 == root[p+1]){
            start = p/2;
        }
    }

    V = roots.size()/2;

	int f=152;
	int f3 = 15;

	int walls[152] = {0,0, 1,0, 2,0, 3,0, 5,0, 6,0, 7,0, 8,0, 9,0, 10,0, 11,0, 13,0, 0,1,
		5,1, 13,1, 0,2, 2,2, 7,2, 9,2, 10,2, 11,2, 13,2, 0,3, 2,3, 5,3, 7,3,
		10,3, 13,3, 0,4, 2,4, 4,4, 5,4, 7,4, 10,4, 13,4, 2,5, 7,5, 9,5, 10,5,
		11,5, 0,6, 2,6, 3,6, 5,6, 7,6, 9,6, 13,6, 0,7, 2,7, 9,7, 10,7, 11,7,
		13,7, 0,8, 2,8, 4,8, 5,8, 6,8, 7,8, 9,8, 10,8, 13,8, 0,9, 0,10, 1,10,
		2,10, 3,10, 5,10, 6,10, 7,10, 8,10, 9,10, 10,10, 11,10, 12,10, 13,10};

	int a[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int a1[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int a2[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int t=0,t1=0,mesafe,i2,sayac=0,sayac2=0,kt;

	matris = new int*[V];
	for(int i=0; i<V; i++) {
		matris[i] = new int [V];
	}

	for(int i=0;i<V;i++){
		for(int j=0;j<V;j++){
			matris[i][j] = 0;
		}
	}

	for(int i=0;i<14;i++){
		for(int j=0;j<roots.size();j+=2){
			if(i == roots.at(j)){
				for(int k=0;k<roots.size();k+=2){
					if(i == roots.at(k) && k != j){
						a[t] = roots.at(k+1);
						t++;
						t1=t;
					}
				}
				t=0;
				if(t1 > 1){
                    int min = fabs(roots.at(j+1) - a[0]);
                    int value = a[0];
                    kt=0;

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j+1) - a[k1]) < min){
                            min = fabs(roots.at(j+1) - a[k1]);
                            value = a[k1];
                            kt = k1;
                        }
                    }

                    int value2;
                    if(roots.at(j+1) > a[kt]){
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j+1) < a[k1] && a[k1] != 50){
                                a1[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j+1) - a1[0]);
                        value2 = a1[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j+1) - a1[k1]) < min){
                                min = fabs(roots.at(j+1) - a1[k1]);
                                value2 = a1[k1];
                            }
                        }
                    }
                    else{
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j+1) > a[k1] && a[k1] != 50){
                                a2[k1] = a[k1];
                                sayac2++;
                            }
                        }
                        min = fabs(roots.at(j+1) - a2[0]);
                        value2 = a2[0];
                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j+1) - a2[k1]) < min){
                                min = fabs(roots.at(j+1) - a2[k1]);
                                value2 = a2[k1];
                            }
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a1[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a2[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j+1)- value);

                    if(roots.at(j+1)<value){
                        for(int k2=roots.at(j+1)+1;k2<value;k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j+1)>value){
                        for(int k2=value+1;k2<roots.at(j+1);k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    for(int i1=0;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1+1) == value && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;

                    if(sayac2 != 0){
                        mesafe = fabs(roots.at(j+1)- value2);

                        if(roots.at(j+1)<value2){
                            for(int k2=roots.at(j+1)+1;k2<value2;k2++){
                                for(int k3=0;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3+1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }

                        if(roots.at(j+1)>value2){
                            for(int k2=value2+1;k2<roots.at(j+1);k2++){
                                for(int k3=0;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3+1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }

                        for(int i1=0;i1<roots.size();i1+=2){
                            if(roots.at(i1) == i && roots.at(i1+1) == value2 && sayac == 0){
                                matris[j/2][i1/2] = mesafe;
                                matris[i1/2][j/2] = mesafe;
                            }
                        }
                        sayac = 0;

                    }
                    sayac2 = 0;
				}

				if(t1 == 1){
                    int min = fabs(roots.at(j+1) - a[0]);
                    int value = a[0];
                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j+1) - a[k1]) < min){
                            min = fabs(roots.at(j+1) - a[k1]);
                            value = a[k1];
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j+1)- value);

                    if(roots.at(j+1)<value){
                        for(int k2=roots.at(j+1)+1;k2<value;k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j+1)>value){
                        for(int k2=value+1;k2<roots.at(j+1);k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    for(int i1=0;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1+1) == value && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;
				}
				t1=0;
			}
		}
	}

	t=0;
	t1=0;

	for(int i=0;i<11;i++){
		for(int j=1;j<roots.size();j+=2){
			if(i == roots.at(j)){
				for(int k=1;k<roots.size();k+=2){
					if(i == roots.at(k) && k != j){
						a[t] = roots.at(k-1);
						t++;
						t1=t;
					}
				}

				t=0;
				if(t1 > 1){
                    int min = fabs(roots.at(j-1) - a[0]);
                    int value1 = a[0];
                    kt = 0;

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j-1) - a[k1]) < min){
                            min = fabs(roots.at(j-1) - a[k1]);
                            value1 = a[k1];
                            kt =k1;
                        }
                    }

                    int value3;
                    if(roots.at(j-1) > a[kt]){
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j-1) < a[k1] && a[k1] != 50){
                                a1[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j-1) - a1[0]);
                        value3 = a1[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j-1) - a1[k1]) < min){
                                min = fabs(roots.at(j-1) - a1[k1]);
                                value3 = a1[k1];
                            }
                        }
                    }
                    else{
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j-1) > a[k1] && a[k1] != 50){
                                a2[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j-1) - a2[0]);
                        value3 = a2[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j-1) - a2[k1]) < min){
                                min = fabs(roots.at(j-1) - a2[k1]);
                                value3 = a2[k1];
                            }
                        }
                    }
                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a1[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a2[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j-1)- value1);

                    if(roots.at(j-1)<value1){
                        for(int k2=roots.at(j-1)+1;k2<value1;k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j-1)>value1){
                        for(int k2=value1+1;k2<roots.at(j-1);k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }
                    for(int i1=1;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1-1) == value1 && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;

                    if(sayac2 != 0){
                        mesafe = fabs(roots.at(j-1)- value3);
                        if(roots.at(j-1)<value3){
                            for(int k2=roots.at(j-1)+1;k2<value3;k2++){
                                for(int k3=1;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3-1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }

                        if(roots.at(j-1)>value3){
                            for(int k2=value3+1;k2<roots.at(j-1);k2++){
                                for(int k3=1;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3-1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }
                        for(int i1=1;i1<roots.size();i1+=2){
                            if(roots.at(i1) == i && roots.at(i1-1) == value3 && sayac == 0){
                                matris[j/2][i1/2] = mesafe;
                                matris[i1/2][j/2] = mesafe;
                            }
                        }
                        sayac = 0;
                    }
                    sayac2 = 0;
				}
				if( t1 == 1){
                    int min = fabs(roots.at(j-1) - a[0]);
                    int value1 = a[0];

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j-1) - a[k1]) < min){
                            min = fabs(roots.at(j-1) - a[k1]);
                            value1 = a[k1];
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j-1)- value1);

                    if(roots.at(j-1)<value1){
                        for(int k2=roots.at(j-1)+1;k2<value1;k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j-1)>value1){
                        for(int k2=value1+1;k2<roots.at(j-1);k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }
                    for(int i1=1;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1-1) == value1 && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;
				}
				t1=0;
			}
		}

	}

    int distance[V];
    bool Set[V];

    for (int i = 0; i < V; i++)
       distance[i] = INT_MAX, Set[i] = false;

    distance[start] = 0;

     int way[V][V];
     for(int i=0;i<V;i++){
     	for(int j=0;j<V;j++){
     		way[i][j] = -1;
		 }
	 }

     int v1[V];

     for(int i=0;i<V;i++)
     	v1[i]= -1;

     int i1,j=0;

     for (int count = 0; count < V-1; count++){
       int min = INT_MAX, min_index;

   		for (int v = 0; v < V; v++){
			if (Set[v] == false && distance[v] <= min){
				min = distance[v];
				min_index = v;
			}
   		}

       int u = min_index;

       Set[u] = true;

       for (int v = 0; v < V; v++)
         if (Set[v] == false && matris[u][v] != 0 && distance[u]+matris[u][v] < distance[v]) {
		 	distance[v] = distance[u] + matris[u][v];
		 	way[v][0] = u;
		 	way[v][1] = v;
		 	for(int k=0;k<V;k++){
		 		if(v1[k] == u){
		 			for(int i=0;i<V;i++){
		 				way[v][i] = way[u][i];
                        if(way[u][i] != -1)
                            i1 = i;
				 	}
		 			way[v][i1+1] = v;
				}
			}
		 	v1[j] =v;
		 	j++;
		 }
     }


    vector <vector <int> >ways;
    for(int i=0;i<V;i++){
        vector <int> row2;
        for(int j=0;j<V;j++){
            if(way[i][j] != -1)
                row2.push_back(way[i][j]);
        }
        ways.push_back(row2);
    }

    if(olcum == 0) {
        (*badCharacters)[index]->setXCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-1]*2]*35+130);
        (*badCharacters)[index]->setYCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-1]*2+1]*35+130);
    }
    else {
        (*badCharacters)[index]->setXCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-3]*2]*35+130);
        (*badCharacters)[index]->setYCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-3]*2+1]*35+130);
    }

    (*fin).clear();

    for(int i=0; i<(*badCharacters).size(); i++) {
        fin->push_back(fini[i]);
    }

    (*coord).clear();
    for(int i=0; i<ways.size(); i++) {
        vector <int> row1;

        for(int j=0; j<ways[i].size(); j++) {
            row1.push_back(ways[i][j]);
        }
        coord->push_back(row1);
    }

    (*ro).clear();
     for(int i=0; i<roots.size(); i++) {
        ro->push_back(roots[i]);
    }
}


#include "Lokasyon.h"

Lokasyon::Lokasyon() {
	x = y = 0;
}

Lokasyon::~Lokasyon()
{
}

int Lokasyon::getXCoordinate() {
	return x;
}

void Lokasyon::setXCoordinate(int x) {
	this->x = x;
}

int Lokasyon::getYCoordinate() {
	return y;
}

void Lokasyon::setYCoordinate(int y) {
	this->y = y;
}



#include "LukeSkywalker.h"
#include "Karakter.h"

LukeSkywalker::LukeSkywalker() {
	setCharacterType("iyi");

	health = 6;
}

LukeSkywalker::~LukeSkywalker()
{
}

int LukeSkywalker::getHealth() {
	return health;
}

void LukeSkywalker::setHealth(int health) {
	this->health = health;
}



#include "MasterYoda.h"

MasterYoda::MasterYoda() {
	setCharacterType("iyi");

	health = 6;
}

MasterYoda::~MasterYoda()
{

}

int MasterYoda::getHealth() {
	return health;
}

void MasterYoda::setHealth(int health) {
	this->health = health;
}




#include "Stormtrooper.h"
#include <math.h>

Stormtrooper::Stormtrooper()
{
    setCharacterType("kotu");
}

Stormtrooper::~Stormtrooper()
{ }

int Stormtrooper::shortestPath(vector<Karakter*>* badCharacters, Karakter * character, int olcum, vector<int>*fin, vector <vector <int> > *coord, vector<int> *ro, int index) { //en kisa yol algoritmasi

    int **matris;
    vector<int>roots;
    int V;
	int root[156] = {4,0, 12,0, 1,1, 2,1, 3,1, 4,1, 6,1, 7,1, 8,1, 9,1, 10,1, 11,1, 12,1, 1,2, 3,2, 4,2, 5,2, 6,2, 8,2, 12,2, 1,3, 3,3, 4,3, 6,3, 8,3, 9,3, 11,3, 12,3, 1,4, 3,4, 6,4, 8,4, 9,4, 11,4, 12,4, 0,5, 1,5, 3,5, 4,5, 5,5, 6,5, 8,5, 12,5, 13,5, 1,6, 4,6, 6,6, 8,6, 10,6, 11,6, 12,6, 1,7, 3,7, 4,7, 5,7, 6,7, 7,7, 8,7, 12,7, 1,8, 3,8, 8,8, 11,8, 12,8, 1,9, 2,9, 3,9, 4,9, 5,9, 6,9, 7,9, 8,9, 9,9, 10,9, 11,9, 12,9, 13,9, 4,10};

	for(int p=0;p<156;p++){
		 roots.push_back(root[p]);
	}

	int start;
	vector<int>finish;

    int fini[(*badCharacters).size()];
    int sayici[(*badCharacters).size()];

    for(int i=0; i<(*badCharacters).size(); i++) {
        sayici[i] = -1;
        fini[i] = -1;
    }

	for(int i=0;i<(*badCharacters).size();i++){
        for(int p=0;p<156;p+=2){
    		if(((*badCharacters)[i]->getXCoordinate()-130)/35 == root[p] &&  ((*badCharacters)[i]->getYCoordinate()-130)/35 == root[p+1]){
    			finish.push_back(p/2);
    			sayici[i]++;
			}
		}
	}

    int cikar = 0;
    for(int i=0; i<(*badCharacters).size(); i++) {
        if(sayici[i] != -1) {
            fini[i] = finish.at(i-cikar);
        }
        if(sayici[i] == -1) {
            cikar ++;
        }
	}

    for(int p=0;p<156;p+=2){
        if((character->getXCoordinate()-130)/35 == root[p] && (character->getYCoordinate()-130)/35 == root[p+1]){
            start = p/2;
        }
    }

    V = roots.size()/2;

	int f=152;
	int f3 = 15;

	int walls[152] = {0,0, 1,0, 2,0, 3,0, 5,0, 6,0, 7,0, 8,0, 9,0, 10,0, 11,0, 13,0, 0,1,
		5,1, 13,1, 0,2, 2,2, 7,2, 9,2, 10,2, 11,2, 13,2, 0,3, 2,3, 5,3, 7,3,
		10,3, 13,3, 0,4, 2,4, 4,4, 5,4, 7,4, 10,4, 13,4, 2,5, 7,5, 9,5, 10,5,
		11,5, 0,6, 2,6, 3,6, 5,6, 7,6, 9,6, 13,6, 0,7, 2,7, 9,7, 10,7, 11,7,
		13,7, 0,8, 2,8, 4,8, 5,8, 6,8, 7,8, 9,8, 10,8, 13,8, 0,9, 0,10, 1,10,
		2,10, 3,10, 5,10, 6,10, 7,10, 8,10, 9,10, 10,10, 11,10, 12,10, 13,10};

	int a[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int a1[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int a2[f3] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50};
	int t=0,t1=0,mesafe,i2,sayac=0,sayac2=0,kt;

	matris = new int*[V];
	for(int i=0; i<V; i++) {
		matris[i] = new int [V];
	}

	for(int i=0;i<V;i++){
		for(int j=0;j<V;j++){
			matris[i][j] = 0;
		}
	}

	for(int i=0;i<14;i++){
		for(int j=0;j<roots.size();j+=2){
			if(i == roots.at(j)){
				for(int k=0;k<roots.size();k+=2){
					if(i == roots.at(k) && k != j){
						a[t] = roots.at(k+1);
						t++;
						t1=t;
					}
				}
				t=0;
				if(t1 > 1){
                    int min = fabs(roots.at(j+1) - a[0]);
                    int value = a[0];
                    kt=0;

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j+1) - a[k1]) < min){
                            min = fabs(roots.at(j+1) - a[k1]);
                            value = a[k1];
                            kt = k1;
                        }
                    }

                    int value2;
                    if(roots.at(j+1) > a[kt]){
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j+1) < a[k1] && a[k1] != 50){
                                a1[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j+1) - a1[0]);
                        value2 = a1[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j+1) - a1[k1]) < min){
                                min = fabs(roots.at(j+1) - a1[k1]);
                                value2 = a1[k1];
                            }
                        }
                    }
                    else{
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j+1) > a[k1] && a[k1] != 50){
                                a2[k1] = a[k1];
                                sayac2++;
                            }
                        }
                        min = fabs(roots.at(j+1) - a2[0]);
                        value2 = a2[0];
                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j+1) - a2[k1]) < min){
                                min = fabs(roots.at(j+1) - a2[k1]);
                                value2 = a2[k1];
                            }
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a1[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a2[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j+1)- value);

                    if(roots.at(j+1)<value){
                        for(int k2=roots.at(j+1)+1;k2<value;k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j+1)>value){
                        for(int k2=value+1;k2<roots.at(j+1);k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    for(int i1=0;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1+1) == value && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;

                    if(sayac2 != 0){
                        mesafe = fabs(roots.at(j+1)- value2);

                        if(roots.at(j+1)<value2){
                            for(int k2=roots.at(j+1)+1;k2<value2;k2++){
                                for(int k3=0;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3+1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }

                        if(roots.at(j+1)>value2){
                            for(int k2=value2+1;k2<roots.at(j+1);k2++){
                                for(int k3=0;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3+1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }

                        for(int i1=0;i1<roots.size();i1+=2){
                            if(roots.at(i1) == i && roots.at(i1+1) == value2 && sayac == 0){
                                matris[j/2][i1/2] = mesafe;
                                matris[i1/2][j/2] = mesafe;
                            }
                        }
                        sayac = 0;

                    }
                    sayac2 = 0;
				}

				if(t1 == 1){
                    int min = fabs(roots.at(j+1) - a[0]);
                    int value = a[0];
                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j+1) - a[k1]) < min){
                            min = fabs(roots.at(j+1) - a[k1]);
                            value = a[k1];
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j+1)- value);

                    if(roots.at(j+1)<value){
                        for(int k2=roots.at(j+1)+1;k2<value;k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j+1)>value){
                        for(int k2=value+1;k2<roots.at(j+1);k2++){
                            for(int k3=0;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3+1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    for(int i1=0;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1+1) == value && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;
				}
				t1=0;
			}
		}
	}

	t=0;
	t1=0;

	for(int i=0;i<11;i++){
		for(int j=1;j<roots.size();j+=2){
			if(i == roots.at(j)){
				for(int k=1;k<roots.size();k+=2){
					if(i == roots.at(k) && k != j){
						a[t] = roots.at(k-1);
						t++;
						t1=t;
					}
				}

				t=0;
				if(t1 > 1){
                    int min = fabs(roots.at(j-1) - a[0]);
                    int value1 = a[0];
                    kt = 0;

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j-1) - a[k1]) < min){
                            min = fabs(roots.at(j-1) - a[k1]);
                            value1 = a[k1];
                            kt =k1;
                        }
                    }

                    int value3;
                    if(roots.at(j-1) > a[kt]){
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j-1) < a[k1] && a[k1] != 50){
                                a1[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j-1) - a1[0]);
                        value3 = a1[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j-1) - a1[k1]) < min){
                                min = fabs(roots.at(j-1) - a1[k1]);
                                value3 = a1[k1];
                            }
                        }
                    }
                    else{
                        a[kt] =50;
                        for(int k1=0;k1<f3;k1++){
                            if(roots.at(j-1) > a[k1] && a[k1] != 50){
                                a2[k1] = a[k1];
                                sayac2++;
                            }
                        }

                        min = fabs(roots.at(j-1) - a2[0]);
                        value3 = a2[0];

                        for(int k1=1;k1<f3;k1++){
                            if(fabs(roots.at(j-1) - a2[k1]) < min){
                                min = fabs(roots.at(j-1) - a2[k1]);
                                value3 = a2[k1];
                            }
                        }
                    }
                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a1[k1] = 50;
                    }
                    for(int k1=0;k1<f3;k1++){
                        a2[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j-1)- value1);

                    if(roots.at(j-1)<value1){
                        for(int k2=roots.at(j-1)+1;k2<value1;k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j-1)>value1){
                        for(int k2=value1+1;k2<roots.at(j-1);k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }
                    for(int i1=1;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1-1) == value1 && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;

                    if(sayac2 != 0){
                        mesafe = fabs(roots.at(j-1)- value3);
                        if(roots.at(j-1)<value3){
                            for(int k2=roots.at(j-1)+1;k2<value3;k2++){
                                for(int k3=1;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3-1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }

                        if(roots.at(j-1)>value3){
                            for(int k2=value3+1;k2<roots.at(j-1);k2++){
                                for(int k3=1;k3<f;k3+=2){
                                    if(walls[k3] == i && walls[k3-1] == k2){
                                        sayac++;
                                    }
                                }
                            }
                        }
                        for(int i1=1;i1<roots.size();i1+=2){
                            if(roots.at(i1) == i && roots.at(i1-1) == value3 && sayac == 0){
                                matris[j/2][i1/2] = mesafe;
                                matris[i1/2][j/2] = mesafe;
                            }
                        }
                        sayac = 0;
                    }
                    sayac2 = 0;
				}
				if( t1 == 1){
                    int min = fabs(roots.at(j-1) - a[0]);
                    int value1 = a[0];

                    for(int k1=1;k1<f3;k1++){
                        if(fabs(roots.at(j-1) - a[k1]) < min){
                            min = fabs(roots.at(j-1) - a[k1]);
                            value1 = a[k1];
                        }
                    }

                    for(int k1=0;k1<f3;k1++){
                        a[k1] = 50;
                    }

                    mesafe = fabs(roots.at(j-1)- value1);

                    if(roots.at(j-1)<value1){
                        for(int k2=roots.at(j-1)+1;k2<value1;k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }

                    if(roots.at(j-1)>value1){
                        for(int k2=value1+1;k2<roots.at(j-1);k2++){
                            for(int k3=1;k3<f;k3+=2){
                                if(walls[k3] == i && walls[k3-1] == k2){
                                    sayac++;
                                }
                            }
                        }
                    }
                    for(int i1=1;i1<roots.size();i1+=2){
                        if(roots.at(i1) == i && roots.at(i1-1) == value1 && sayac == 0){
                            matris[j/2][i1/2] = mesafe;
                            matris[i1/2][j/2] = mesafe;
                        }
                    }
                    sayac = 0;
				}
				t1=0;
			}
		}

	}

    int distance[V];
    bool Set[V];

    for (int i = 0; i < V; i++)
       distance[i] = INT_MAX, Set[i] = false;

    distance[start] = 0;

     int way[V][V];
     for(int i=0;i<V;i++){
     	for(int j=0;j<V;j++){
     		way[i][j] = -1;
		 }
	 }

     int v1[V];

     for(int i=0;i<V;i++)
     	v1[i]= -1;

     int i1,j=0;

     for (int count = 0; count < V-1; count++){
       int min = INT_MAX, min_index;

   		for (int v = 0; v < V; v++){
			if (Set[v] == false && distance[v] <= min){
				min = distance[v];
				min_index = v;
			}
   		}

       int u = min_index;

       Set[u] = true;

       for (int v = 0; v < V; v++)
         if (Set[v] == false && matris[u][v] != 0 && distance[u]+matris[u][v] < distance[v]) {
		 	distance[v] = distance[u] + matris[u][v];
		 	way[v][0] = u;
		 	way[v][1] = v;
		 	for(int k=0;k<V;k++){
		 		if(v1[k] == u){
		 			for(int i=0;i<V;i++){
		 				way[v][i] = way[u][i];
                        if(way[u][i] != -1)
                            i1 = i;
				 	}
		 			way[v][i1+1] = v;
				}
			}
		 	v1[j] =v;
		 	j++;
		 }
     }

    vector <vector <int> >ways;
    for(int i=0;i<V;i++){
        vector <int> row2;
        for(int j=0;j<V;j++){
            if(way[i][j] != -1)
                row2.push_back(way[i][j]);
        }
        ways.push_back(row2);
    }

    if(olcum == 0) {
        (*badCharacters)[index]->setXCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-1]*2]*35+130);
        (*badCharacters)[index]->setYCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-1]*2+1]*35+130);
    }
    else {
        (*badCharacters)[index]->setXCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-2]*2]*35+130);
        (*badCharacters)[index]->setYCoordinate(roots[ways[fini[index]][ways[fini[index]].size()-2]*2+1]*35+130);
    }

    (*fin).clear();
    for(int i=0; i<(*badCharacters).size(); i++) {
        fin->push_back(fini[i]);
    }

    (*coord).clear();
    for(int i=0; i<ways.size(); i++) {
        vector <int> row1;

        for(int j=0; j<ways[i].size(); j++) {
            row1.push_back(ways[i][j]);
        }
        coord->push_back(row1);
    }

    (*ro).clear();
     for(int i=0; i<roots.size(); i++) {
        ro->push_back(roots[i]);
    }
}





